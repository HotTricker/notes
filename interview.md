# Interview

- [ ] 自我介绍
- [ ] 业务介绍
- [ ] 业务亮点
  - 高可用、高可靠、节约资源
- [x] 印象深刻的问题
  - 多个程序并发下载并使用同一张图片，尽量避免重复下载。判断图片是否存在，存在就使用。有两种情况会出错，一种是其他协程下载未完成就开始使用，一种是下载过程中其他协程开始下载，使用时图片不完整。解决方式是先下载成别名再mv。后来同样的策略用在共享存储上，由于共享存储的机制，该策略无法解决问题，改为划分文件夹。然后mq抖动时再次出现该问题，由于mq重复消费又导致了多个线程的并发读写，后来通过在文件夹后加随机字符串的方式解决。
- 经验教训
  - 记得问不足之处
  - 设计的东西不用说太多，要对应岗位职责
  - 用的少的地方简单说用到的地方，不要说用的少，容易堵上话题

## Linux

- [x] top
  实时监控，显示整体性能信息和正在运行的进程相关信息。
  - 显示系统的运行时间、平均负载（1，5，15分钟）
  - 当前运行的进程线程数
  - 总体CPU使用率和各个核心的使用情况
    - us 用户空间、sy 系统空间、ni 改变过优先级的进程消耗掉的CPU时间、id 空闲、wa 等待、hi 硬中断、si 软中断
  - 内存和交换区的总量/可用/缓存情况，内存不够时会把暂时不用的放在交换区，交换区升高说明真不够用了。
  - 进程信息
    - PID 进程id、USER 用户、PR 优先级、NI nice值、VIRT 虚拟内存总量、RES 实际内存、SHR 共享内存、S 进程状态
- [x] "too many open files"解决
  句柄超出系统限制，通过ulimit -a可以查看当前系统设置的最大句柄数，lsof -p查看单个进程打开文件数，修改系统配置文件limits.conf可以增加
- [x] 软链接硬链接区别
  - 硬链接允许一个文件有多个有效路径名，防止误删
  - 软连接类似快捷方式，是一个特殊的文件，访问的时候自动替换为对应的文件路径
- [ ] 怎么排查内存泄漏
  1. 使用vmstat查询内存变化情况
  2. 使用memleak检查是否发生了泄露并根据调用栈定位内存的分配位置，从而释放不再使用的内存。

## go

- 通道
  - 本质上讲通道就是一个基于锁的循环队列，首先获取锁，然后进行竞争检查、指针检查，然后更新读写位置，记录数据，释放锁
  - [x] 收发通道
    - 收发通过<-进行，如果没有缓冲且无接受，发送方阻塞
    - 接收是阻塞的，如果想非阻塞应该用“，ok”，会造成较高的CPU占用，一般只配合select做超时检测
  - [ ] select
    - case里必须是I/O操作，只要有一个case完成就会继续往下执行
  - [x] 什么时候报panic/死锁
    - 关闭未初始化/已关闭的通道会panic
    - 发送给未初始化的通道会死锁，给关闭的通道会panic
    - 接收未初始化的通道会死锁
  - [x] 通道有什么用
    - 解决go协程的同步和数据共享问题
  - [x] chan内存泄漏
    - 接收者已经退出/因为异常提前退出，发送者阻塞
- [x] go 远程调试
  在远程服务器安装dlv，启动dlv，在ide配置debug监听端口
- [ ] go 内存管理
- [x] 解决内存泄漏
  - go的内存泄漏原因可能有循环引用、没有正确处理的时候会导致内存无法释放
    - 可以手动解除引用
  - 未及时关闭资源，比如文件、网络连接等使用完成后没有关闭
    - 及时关闭资源，可以使用defer关键字
  - 协程泄露，没有正确的关闭或释放协程，导致协程持续运行。
    - 使用context包管理协程的生命周期
  - 使用性能分析工具
  - 使用代码检测工具并进行代码审查
- [x] context
  - 用于管理协程的生命周期，是协程并发安全的，可以根据已有的context派生新的，只要取消一个派生出来的都会关闭
- [x] 内存逃逸
  - 函数返回局部变量指针
  - 发送指针或带有指针的值到channel，编译器无法确定变量的释放时间
  - interface类型逃逸
    - `fmt.Printf("%v", str)` 值逃逸
    - `fmt.Printf("%p", &str)` 只有值传递，地址被装在一个堆上的变量里，堆上的变量不能存栈上的地址，str逃逸到堆上，在堆上分配内存
  - 闭包产生逃逸
  - 栈空间不足
  - 使用指针类型的切片

## redis

- [ ] **简介**
  - 服务器循环处理事件，包括文件事件（建立连接，读写，关闭连接）和时间事件（一般只有serverCron，执行清理过期键、AOF重写、RDB的savepoint检查等）
  - 适合较小数据量的高性能计算
- [ ] **redis为什么快**
  - 内存存储
  - 单线程实现（所有网络请求用一个线程处理）+多路复用I/O(减少网络上I/O的时间)
  - 优化的数据结构
  - redis自己构建了虚拟内存机制，把暂时不经常访问的数据从内存交换到磁盘
- [x] **redis数据类型**
  - string（缓存结构体消息，计数），list（可以实现异步队列），hash（保存结构体，可以单独保存某个字段），set，zset（借助跳表实现）
  - 位图（以位为单位的数组，适合统计数据）、Hyperloglog、Geospatial（存地理信息）
- [ ] redis提高数据库容量的方式
  - 将数据分割到多个redisServer上
  - 使用虚拟内存把不经常访问的数据交换到磁盘上
- [x] **redis持久化**
  - 分为RDB和AOF以及混合三种。RDS是默认存储方式，保存某一时刻数据的快照，符合自定规则/执行save、bgsave（阻塞时间短）、flushall命令/第一次主从复制会触发快照，优点是占用空间小，性能好，缺点是会丢失最后一次快照以后的数据；AOF记录写过的所有命令，按顺序回放进行恢复，如果AOF体积过大，会自动重写成恢复当前数据集的的命令集合，缺点主要是性能差，不建议单独使用。
- [ ] 持久化数据和缓存扩容
  - 当做缓存使用，使用一致性哈希实现动态扩容缩容
  - 当作持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点数量一旦确定不能变化，否则必须使用可以运行时数据平衡的一套系统（比如redis集群）
- [ ] **redis过期键的删除策略**
  - 惰性删除+定时删除：惰性删除指的是不会主动删除数据，在访问时再检查是否过期，(cpu友好、空间浪费)；定时删除是指redis会周期性的随机测试一批设置了过期时间的key并处理，测试到的已过期key会被删除(空间友好、影响cpu)
- [ ] redis过期相关命令
  - expire(按秒设置过期)、pexpire(按毫秒过期)、persist(移除过期时间)、ttl(查看剩余时间)
- [ ] **内存淘汰策略**
  - 内存不够用时触发淘汰策略，删除一些不常用的数据
  - 移除设置过期时间的key(最近最少使用/最不经常使用/将过期的/随机)、移除数据集中的(最近最少使用/随机/最不经常使用的key)、禁止写入数据
- **缓存(使用redis做缓存)**
  - 缓存异常有四种类型：缓存与数据库不一致、缓存击穿、缓存雪崩、缓存穿透
    - [ ] 缓存与数据库不一致
      - 有四种方案保证缓存与数据库双写时的数据一致性：先更新数据库后更新缓存(导致缓存中脏数据)、先更新缓存后更新数据库(如果数据库失败会造成不一致)、先删除缓存后更新数据库(为了防止删除期间有人读，可以延时双删)、先更新数据库后删除缓存(删除可能失败，可以用消息队列进行补偿删除)
    - [ ] 缓存击穿
      - 某个热点key失效，大并发集中进行请求导致高并发访问数据库。可以通过互斥锁或者队列来控制读写缓存的线程数量，其他线程阻塞，吞吐量下降；也可以对热点key不设置过期时间，或者要过期时通过后台异步线程进行缓存的构建
    - [ ] 缓存雪崩
      - 大规模的key失效导致大量请求打在数据库上，有两种可能：一种是redis宕机；一种是采用了相同的过期时间。
        - 事先：均匀过期、热点key不过期或者过期前刷新、分级缓存并且每级失效时间不同；保证redis高可用；
        - 事中：互斥锁限制读写缓存的数量(吞吐量下降)；使用熔断机制限流降级，部分用户可用，其他用户刷新几次后得到结果
    - [ ] 缓存穿透
      - 用户请求的数据在redis中不存在，大量的请求打在数据库上。如果空的key有限或者重复率高，可以将无效的key也写入redis；否则可以使用布隆过滤器提前判断key，判断不存在则一定不存在、直接返回，判断存在则大概率存在(可能误判)
  - [ ] 缓存预热：系统上线后先把数据加载到缓存系统，防止初始状态时高并发的访问数据库
  - [ ] 缓存降级：缓存失效时不去访问数据库而是直接返回默认数据或者内存结果，一般是有损的操作，要尽量减少对业务的影响
- [ ] redis事务：不是传统意义上的事务，只是一个批量执行脚本，一条命令失败不会导致之前的命令回滚，之后的命令也依然会执行。
- [ ] **常见使用方式**
  - 单副本：简单方便性价比高；不保证可靠性
  - 主从：实时同步，高可靠，读写分离；故障恢复复杂，需要手动升主并让其他从复制，写能力和存储能力受限
  - 哨兵：自动实现故障发现、故障自动转移、配置中心和客户端通知；从节点不提供服务带来资源浪费、不能读写分离、只有针对主节点的高可用切换
  - 集群：解决单机内存、并发、流量等瓶颈，最少6节点，主提供读写，从备用。无中心、数据存储在多个节点、可扩展、高可用；实现复杂、容易因为阻塞下线、异步复制不保证强一致性、无法区分冷热数据、批量操作受限、事务受限
  - 自研
- [ ] redis主从复制
  - 如果是slave重连，只复制缺少的部分，否则进行完全同步：生成一份rdb文件同时将客户端收到的写命令缓存在内存，然后将rdb发送给从，从先写入磁盘再加载到内存，然后同步之前缓存的写命令的数据。如果复制过程中连接断了，支持断点续传
- [ ] redis哨兵工作
  - 哨兵每秒一次ping其他的主、从、哨兵
  - 如果一个实例最后一次有效回复超过了规定的时间，将其标记为主观下线
  - 如果一个master被标记为主观下线，所有哨兵以每秒一次的频率确认其的确进入主观下线，如果足够数量的哨兵都这样认为，标记为客观下线，此时会加快发送给其slave消息的频率
  - 若没有足够数量的哨兵同意，客观下线会变成主观下线，如果重新回复了ping，主观下线会移除
  - 客观下线后，哨兵投票选一个哨兵节点进行故障处理，在从节点中选一个主，其他节点挂载到新的主节点并自动复制主节点的数据。
  - [ ] 选为master的标准：跟master断开的时长 > slave优先级 > 复制的数据多少 > run id
- [ ] redis cluster如何实现数据分布
  - 有16384个hash slot，每个master持有部分slot，增加一个master就把其他master的slot移动部分过去，减少一个master就把它的slot移动到其他master，移动的成本非常低。
- [ ] redis内存优化
  - 控制key的数量，可以利用redis的数据结构
  - 缩减键值对象的长度
  - 编码优化
- [ ] redis处理高并发读
  - redis单机读的qps在万级，使用一主多从+哨兵集群，主从复制，读写分离。海量数据可以用cluster模式，多个主分别存储。
- [ ] redis/map对比
  - redis可以用几十G内存来缓存，Map不行
  - redis可以持久化，Map是内存对象
  - redis可以实现分布式缓存，并且可以高并发
  - redis有过期机制，有丰富的API
- [x] redis stream
  - 适用于消息队列的高级数据结构，之前的list实现比较难重复消费，订阅/发布如果订阅者不在线消息会丢失，stream是一种标准化的消息队列，`XADD qname ID key [value ...]`,`XREAD [count] [block time] STREAMS qname`(可以阻塞或者非阻塞),`XACK`,`XPENDING`(查看未确认消息),支持消费者组，pending列表其实就是做消息备份和转移。

## mysql

- [ ] 数据库三范式
  - 第一范式：列的原子性。第二范式：实体的属性完全依赖于主关键字（不能依赖联合主键的一部分，否则可能会导致数据冗余和更新不便）。第三范式：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键A可以获取非主键B
- [ ] InnoDB和MyISAM的区别
  - InnoDB支持事务、外键，MyISAM不支持
  - InnoDB是聚集索引，数据和索引绑定在一起，必须要有主键；MyISAM数据和文件是分离的，索引保存数据文件的指针
  - InnoDB不支持全文索引，MyISAM支持
  - InnoDB不保存表的行数
  - MyISAM采用表级锁，InnoDB支持行级锁和表级锁，默认行级锁
- [ ] 超键、候选键、主键、外键
  - 超键：在关系中能唯一标识元组的属性集；候选键：最小超键，没有冗余；主键：表中唯一和完整标识的数据列或者属性组合，一个数据列只能有一个主键且非空；外键：在一个表中存在的另一个表的主键。
- [ ] sql约束有哪几种
  - 非空、不可重复、主键、外键、控制值的范围
- [ ] varchar和char的区别
  - char是定长字段，varchar申请的是最大长度，占用空间为实际长度+1，最后一个字符存实际空间，在效率上char>varchar。
- [ ] in和exist的区别
  - in把内表和外表做hash链接，exists对外表做loop循环，每次循环对内表进行查询
  - 如果内外表大小相当，则性能相当。否则子查询表大的用exists，子查询表小的用in
  - not in如果是主键，走索引，否则和not exist一样不走索引
- [ ] delete、truncate、drop的区别
  - 速度上drop>truncate>>delete
  - delete属于DML语言，其他的是DDL语言
  - delete可回滚、其他不可回滚
  - delete只删除指定数据，表结构还在；truncate删除所有数据；drop删除表
- [ ] 存储过程
  - 存储过程是一些预编译的sql语句，这些语句像一些方法一样实现一些功能，执行效率高，但复用性不高时也不方便。
- [ ] mysql查询执行过程
  1. 客户端通过tcp连接发送连接请求到mysql连接器，连接器对该请求进行权限验证和连接资源分配
  2. 查缓存（任何字符上的不同，比如空格、注释都会导致缓存不命中）
  3. 语法分析（检查语法错误，检查表和列是否存在等）
  4. 优化（是否使用索引，生成执行计划）
  5. 交给执行器，数据保存到结果集，逐步将数据缓存到查询缓存中，结果集返回给客户端
  更新语句还涉及到是否有排他锁、写binlog、刷盘、是否commit等。
- 事务
  - [ ] 数据库事务的定义
    - 一个不可分割的数据库操作序列，其结果使数据库从一种一致性状态变成另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。
  - [ ] 事务的特征
    - 原子性（要么都做，要么都不做）
    - 一致性必须使数据库从一种一致性状态变成另一种一致性状态(如果只有部分修改成功并且修改写入物理数据库，这时数据库处于一种不正确或者不一致的状态)
    - 隔离性：一个事务不能被其他事务干扰，并发执行的各个事务之间不能互相干扰
    - 持久性：一个事务一旦提交，对数据的改变是永久性的，接下来的其他操作或故障不应该对其结果有任何影响
  - [ ] mysql的四种隔离级别
    - 读未提交：一个事务可以看到其他未提交事务的执行结果；
    - 读已提交：大多数据库系统的默认级别，不可重复读
    - 可重读：mysql默认的级别，同一事务的多个实例并发读数据，会看到同样的数据行，但会有幻读。mysql在这一级别通过行锁和间隙锁的组合 Next-Key 锁解决了幻读问题。
    - 可串行化：通过强制事务排序，不可能互相冲突，但是会有大量超时和锁竞争。
  - [ ] 脏读、不可重复读、幻读
    - 脏读：事务A读取B更新的数据，然后B回滚，A读到的数据是脏数据
    - 不可重复读：A多次读统一数据，B在A读过程中更新并提交，A多次读结果一致（侧重改）
    - 幻读：A修改所有数据，但B同时插入了一条数据，A改完后发现少改了一条（侧重增删）
  - [ ] 实现
    - 基于重做日志和回滚日志。提交一个事务必须先把所有日志写入重做日志进行持久化，从而确保原子性和持久性，有修改事务时会产生回滚日志，如果需要回滚会根据反向语句进行回滚，确保原子性和一致性。
- [ ] binlog
  - 记录所有数据库表结构变更以及表数据修改的二进制日志，以事件形式记录，还包括执行耗时，mysql的二进制日志是事务安全型的，主要目的是复制和恢复
  - statement基于sql语句的模式，但是某些语句比如uuid可能导致数据不一致；row记录行的变化，但是日志大并且可能提高从库延迟；mix是混合模式，根据语句选用具体模式。
- [ ] 是否可以在事务中混合使用存储引擎
  - 尽量不要。事务由下层存储引擎实现，如果混合使用了非事务型的表，一旦发生回滚会导致非事务型表的数据无法撤销，从而导致事务不一致。
- [ ] mvcc
  - 多版本并发控制，通过保存数据在某个时间点的快照实现
  - 实现原理：Innodb聚簇索引记录包括三个隐藏的列，row id(隐藏的自增id)、事务id(记录最后一次修改的事务)、回滚指针(指向这条记录的上一个版本)，这个历史版本存在undo log中。如果要更新，对要修改的行加排他锁然后将原记录放入undo log，接着修改行和事务ID，将回滚指针指向undo log中的原记录，接着提交事务释放锁。
- 锁
  - [ ] 为什么要加锁
    - 并发的存取数据如果不加控制的话可能会读写不正确的数据，破坏数据库一致性
  - [ ] 按照锁的粒度划分有哪些类型
    - 行级锁：开销大，加锁慢，可能死锁；粒度小，并发度高，冲突概率低（mysql通过索引上的索引项加锁实现，只有通过索引条件检索数据才能使用，否则会使用表锁）
    - 表级锁：实现简单，资源消耗小
    - 页级锁：介于二者之间
  - [ ] 从锁的类别上分MySQL都有哪些锁
    - 共享锁：读锁，要读数据时对数据加共享锁，可以加多个
    - 排他锁：写锁，要写数据是加排他锁，只能加一个，与其他的排他锁或者共享锁都互斥
  - [ ] 乐观锁和悲观锁
    - 乐观锁假定不会冲突，只在提交时检查是否违反数据完整性，修改数据时把事务锁起来，通过version的方式锁定
    - 悲观锁假定会冲突，屏蔽一切可能违反数据完整性的操作，查询完就把事务锁起来，直到提交事务
  - [ ] 什么是死锁，怎么解决
    - 两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环
    - 减少死锁的方法：
      - 如果不同程序并发存取多个表，尽量约定相同的顺序访问表
      - 同一个事务中尽可能一次锁定所有需要的资源
      - 通过使用更大粒度的锁来减少死锁概率
  - [ ] 隔离级别和锁的关系
    - 读未提交：读数据不加锁
    - 读已提交：读数据加共享锁，语句执行完释放
    - 可重复读：读数据加共享锁，事务提交后释放
    - 可序列化：锁定整个范围的键并一致持有到事务完成
  - [ ] 优化锁
    - 使用较低的隔离级别
    - 设计索引，尽量使用索引访问数据，加锁更精确
    - 选择合理的事务大小，一次性请求足够级别的锁
    - 不同程序访问一组表时尽量约定相同的顺序来访问表，对于一张表尽量用固定顺序访问表中的行，减少死锁
    - 尽量使用相等条件访问数据，避免间隙锁对并发插入的影响
    - 不要申请超过需要的锁级别
    - 查询不必要的时候不加锁
    - 特定的事务申请表锁来避免死锁
- 索引
  - 索引是一种特殊的文件，包含对数据表里所有记录的引用指针
  - [ ] 优缺点
    - 大大加快数据检索速度，提高系统性能；创建和维护要消耗时间和物理空间
  - [ ] mysql的索引类型：
    - 存储形式：BTree索引、B+Tree索引、Hash索引、full-index全文索引、R-Tree索引
    - 应用层次：
      - 普通索引：一个索引只包含单个列，一个表可以有多个单列索引
      - 唯一索引：索引的值必须唯一但可以为空
      - 复合索引：多列值组成一个索引用于组合搜索
      - 聚簇索引：并不是单独的索引类型，而是存储方式，Innodb就是在一个结构中保存了B+Tree索引和数据行
      - 非聚簇索引
    - 根据物理顺序和键值的关系：聚集索引、非聚集索引
  - [ ] 为什么索引默认使用B+树
    - 相比B树
      - B+树磁盘读写代价更低：树内部节点没有指向关键字具体信息的指针，节点更小，一次性读入内存的待查关键字更多，I/O次数低
      - 区间查询更方便，直接扫一遍叶子节点即可
    - hash
      - 可以快速定位但是没有顺序，I/O复杂度高
      - 不支持范围查询
      - 不能利用索引排序
      - 有大量重复键的时候存在哈希碰撞问题，效率低
    - 红黑树：高度随数据量增加，I/O代价高
  - [ ] 聚簇索引与非聚簇索引
    - 聚簇索引的叶子节点存整行数据，非聚簇索引存主键的值
    - 通常主键（聚簇）索引只查一次，非聚簇索引需要回表多次（如果一个索引包含所有需要查询字段的值，也就是覆盖索引，不需要回表），回表是随机I/O，次数越多越倾向于全表扫描
  - [ ] 联合索引
    - 可以使用多个字段同时建立一个索引，叫做联合索引，如果想要命中索引，需要按照建立时的字段顺序挨个使用，因为mysql要求索引有序，索引会按照建立的顺序进行排序。一般热点字段放前面
  - [ ] 最左前缀原则
    - where字句中最频繁的一列放在最左边，mysql一直向右匹配到范围查询就停止匹配。=和in可以乱序。
  - [ ] 前缀索引
    - 只要把很长字段前面的公共部分作为一个索引即可，但是order by不支持前缀索引
  - [ ] 索引下推
  - [ ] 查询是否用到索引
    - explain关键字，通过type判断级别，通过possible_keys看查询时用到的索引，通过key看实际决定查询结果时使用的索引
  - [ ] 为什么建议使用自增长主键作为索引
    - 结合B+树特点，自增主键是连续的，再插入过程中尽量减少页分裂，并减少数据的移动，每次都插入到最后
  - [ ] 创建索引的方式
    - create table时；alter table；create index
  - [ ] 建索引的原则
    - 最左前缀匹配原则
    - 尽量选择区分度高度列作为索引
    - 索引列不要参与计算
    - 尽量扩展索引而不是新建索引
  - [ ] 索引查询是否一定能提高性能
    - 不一定，索引需要存储和维护；索引范围查询适合两种情况：基于范围的检索；基于非唯一性索引的检索
  - [ ] 索引失效的情况
    - 使用!=,<>；类型不一致导致的索引失效；函数/运算符导致的索引失效；OR连接不同字段；模糊搜索；not in、not exists
- [ ] 分库分表
  - 原因
    - 单表数据量比较大的时候，性能会下降，可以将一个表中的数据按一定规则拆分成多个表，将每个表的数据控制在一定范围内
    - 如果并发数比较大，可以将一个库的数据拆分到多个
  - 水平拆分和垂直拆分
    - 水平拆分：把一个表的数据放到多个库多个表，表结构都一样，可以用多个库来抗高并发和扩容
    - 垂直拆分：扒一个很多字段的表拆分到多个表或者多个库，热点字段放一个表，其他放在别的表里，可以缓存更多的行。
  - 方式
    - 一种是按范围来分，每个库一段连续数据，比如按时间分表，但是热点可能都在最新的数据上
    - 另一种是按某个字段hash均匀分散，可以分配每个库的数据量和压力，但是扩容麻烦，之前的数据需要重新计算hash然后迁移

## 网络

- [ ] OSI七层模型和TCP五层模型
  - OSI
    - 应用层：为应用程序提供网络服务
    - 表示层：数据格式转换、数据压缩、加密
    - 会话层：建立、断开和维护通信连接
    - 传输层：为上层协议提供端到端的可靠传输
    - 网络层：寻址和路由
    - 数据链路层：定义通过通信媒介互连的设备之间传输的规范
    - 物理层：利用物理传输介质为数据链路层提供物理连接
  - TCP：把应用层表示层会话层都合并为应用层
- [ ] 面向有连接型和面向无连接型
  - 面向有连接型传输包括会话建立、传输数据和会话断开，此外还包括传输可靠性的各种措施，比如超时重传、流量控制等，比如TCP
  - 面向无连接型传输仅提供基本的数据传输功能，即使接收端不存在，也能发送数据包，常见的有UDP、IP
- [ ] TCP UDP区别
  - TCP是面向连接型的，UDP是面向无连接型
  - TCP是一对一传输，UDP支持一对一、一对多、多对一、多对多的交互通信
  - TCP把上层的报文看成字节流，拆分成大小不等的数据块，并添加TCP首部；UDP既不拆分也不合并，仅添加UDP首部
  - TCP支持传输可靠性的多种举措，包括保证传输顺序、重发机制、流量控制和拥塞控制，UDP仅提供基本的数据传输能力
- [ ] TCP UDP对应的应用层协议
  - TCP：FTP、HTTP、SSH
  - UDP：DNS、TFTP、SNMP
<!-- - [x] 三次握手、四次挥手
  - TIME_WAIT原因：客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送断开请求报文，如果客户端不等待2*MSL直接CLOSED会导致服务端无法进入CLOSED，或者有可能被新的连接接收到 -->
- [ ] ARQ协议
  - 自动重传请求，如果发送后一段时间没有收到确认回执，通常会重新发送
  - 停止等待ARQ：如果接收方没有回ACK，发送方重新发送，并且维护一个超时计时器，超时事件会比数据往返传输的事件长一些。
  - 连续ARQ：维护一个窗口，窗口内有多个分组，窗口内的分组可以连续发送而不等待ACK，对按序到达的最后一个分组，接收方发送ACK，然后该序号后的分组会重新发送给接收端。可以提高信道利用率。
- [ ] TCP流量控制
  - 控制发送端发送端速率，接收端会告知自己所能接收的数据大小，发送端不会发送超过这个数据量的数据，这个大小称为窗口
- [ ] TCP拥塞控制
  - 如果在通信开始时立即把大量的数据注入网络，可能引起网络阻塞，常见的策略有：慢启动、快重传与快恢复
  - 慢启动：通信开始时定义一个拥塞窗口，窗口大小为1，每收到一个ack就增大拥塞窗口，发送端发送时选择拥塞窗口和流量控制窗口的最小值(可能以更小的数据量进行发送)。
  - 快重传：如果收到了失序报文，及时发送对最后一个有序报文段的确认，如果发送方连续收到三个重复确认，就应当立即重传未收到的报文段。因为这个时候大概率没有发生拥塞，发送方只把慢开始门限减半，然后再加法增大
- [ ] TCP粘包
  - 如果客户端连续不断发送数据包，服务端接收的数据可能会出现两个数据包粘在一起的情况。因为TCP是基于字节流的，也没有表示数据长度的字段
  - 如果发送的数据过小，默认会把数据包合并发送，这时会粘包；接收方会把数据放置在接收缓冲区，如果应用层不能及时的读取，下一个数据到来会有一部分放入缓冲区末尾，导致粘包
  - 可以在包尾加上特殊字符或者报文首部加上包的长度防止粘包。
- [ ] http和https的区别
  - http全称是超文本传输协议，客户端和服务端通信时将信息以http报文的形式传输
  - 可以简单认为https=http+加密+认证+完整性保护
  - http通信使用明文，可能被窃听；通信双方的身份无法得到认证；无法验证报文的完整性
- [ ] http是无状态协议，怎么解决
  - 协议自身不对请求和响应之间的通信状态做保存，对请求和响应都不做持久化处理，这样可以更快的处理大量事务
  - 引入cookie状态管理。在请求和响应报文中写入cookie信息来控制客户端的状态。客户端会根据服务端响应报文的set-cookie字段保存cookie，下次发送请求时自动在请求报文中加入cookie值发送出去，服务端收到后检查是哪一个客户端并对比服务器上的记录，得到之前的状态信息。
- [ ] URI和URL的区别
  - URI是统一资源标识符，唯一标识一份资源。URL是统一资源定位符，是URI的子集。
- [ ] 常见的http动词
  - GET：从服务器获取资源
  - POST：在服务器新建资源
  - PUT：在服务器更新资源
  - DELETE：删除资源
  - HEAD：获取资源的元数据
  - OPTIONAL：查询对指定资源支持的方法

## 容器

- [ ]程序怎么部署的
