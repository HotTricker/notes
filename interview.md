# Interview

- [ ] 自我介绍
- [ ] 业务介绍
- [ ] 业务亮点
  - 高可用、高可靠、节约资源
- [x] 印象深刻的问题
  - 多个程序并发下载并使用同一张图片，尽量避免重复下载。判断图片是否存在，存在就使用。有两种情况会出错，一种是其他协程下载未完成就开始使用，一种是下载过程中其他协程开始下载，使用时图片不完整。解决方式是先下载成别名再mv。后来同样的策略用在共享存储上，由于共享存储的机制，该策略无法解决问题，改为划分文件夹。然后mq抖动时再次出现该问题，由于mq重复消费又导致了多个线程的并发读写，后来通过在文件夹后加随机字符串的方式解决。
- 经验教训
  - 记得问不足之处
  - 设计的东西不用说太多，要对应岗位职责
  - 用的少的地方简单说用到的地方，不要说用的少，容易堵上话题

## Linux

- [x] top
  实时监控，显示整体性能信息和正在运行的进程相关信息。
  - 显示系统的运行时间、平均负载（1，5，15分钟）
  - 当前运行的进程线程数
  - 总体CPU使用率和各个核心的使用情况
    - us 用户空间、sy 系统空间、ni 改变过优先级的进程消耗掉的CPU时间、id 空闲、wa 等待、hi 硬中断、si 软中断
  - 内存和交换区的总量/可用/缓存情况，内存不够时会把暂时不用的放在交换区，交换区升高说明真不够用了。
  - 进程信息
    - PID 进程id、USER 用户、PR 优先级、NI nice值、VIRT 虚拟内存总量、RES 实际内存、SHR 共享内存、S 进程状态
- [x] "too many open files"解决
  句柄超出系统限制，通过ulimit -a可以查看当前系统设置的最大句柄数，lsof -p查看单个进程打开文件数，修改系统配置文件limits.conf可以增加
- [x] 软链接硬链接区别
  - 硬链接允许一个文件有多个有效路径名，防止误删
  - 软连接类似快捷方式，是一个特殊的文件，访问的时候自动替换为对应的文件路径

## go

- 通道
  - 本质上讲通道就是一个基于锁的循环队列，首先获取锁，然后进行竞争检查、指针检查，然后更新读写位置，记录数据，释放锁
  - [x] 收发通道
    - 收发通过<-进行，如果没有缓冲且无接受，发送方阻塞
    - 接收是阻塞的，如果想非阻塞应该用“，ok”，会造成较高的CPU占用，一般只配合select做超时检测
  - [ ] select
    - case里必须是I/O操作，只要有一个case完成就会继续往下执行
  - [x] 什么时候报panic/死锁
    - 关闭未初始化/已关闭的通道会panic
    - 发送给未初始化的通道会死锁，给关闭的通道会panic
    - 接收未初始化的通道会死锁
  - [x] 通道有什么用
    - 解决go协程的同步和数据共享问题
  - [x] chan内存泄漏
    - 接收者已经退出/因为异常提前退出，发送者阻塞
- [x] go 远程调试
  在远程服务器安装dlv，启动dlv，在ide配置debug监听端口
- [ ] go 内存管理
- [x] 解决内存泄漏
  - go的内存泄漏原因可能有循环引用、没有正确处理的时候会导致内存无法释放
    - 可以手动解除引用
  - 未及时关闭资源，比如文件、网络连接等使用完成后没有关闭
    - 及时关闭资源，可以使用defer关键字
  - 协程泄露，没有正确的关闭或释放协程，导致协程持续运行。
    - 使用context包管理协程的生命周期
  - 使用性能分析工具
  - 使用代码检测工具并进行代码审查
- [x] context
  - 用于管理协程的生命周期，是协程并发安全的，可以根据已有的context派生新的，只要取消一个派生出来的都会关闭
- [x] 内存逃逸
  - 函数返回局部变量指针
  - 发送指针或带有指针的值到channel，编译器无法确定变量的释放时间
  - interface类型逃逸
    - `fmt.Printf("%v", str)` 值逃逸
    - `fmt.Printf("%p", &str)` 只有值传递，地址被装在一个堆上的变量里，堆上的变量不能存栈上的地址，str逃逸到堆上，在堆上分配内存
  - 闭包产生逃逸
  - 栈空间不足
  - 使用指针类型的切片

## redis

- [ ] 简介
  > 服务器循环处理事件，包括文件事件（建立连接，读写，关闭连接）和时间事件（一般只有serverCron，执行清理过期键、AOF重写、RDB的savepoint检查等）
- [x] redis数据类型，用过哪些
  > string（缓存结构体消息，计数），list（异步队列），hash（保存结构体，可以单独保存某个字段），set，zset（跳表）
- [x] redis stream
  > 适用于消息队列的高级数据结构，之前的list实现比较难重复消费，订阅/发布如果订阅者不在线消息会丢失，stream是一种标准化的消息队列，`XADD qname ID key [value ...]`,`XREAD [count] [block time] STREAMS qname`(可以阻塞或者非阻塞),`XACK`,`XPENDING`(查看未确认消息),支持消费者组，pending列表其实就是做消息备份和转移。
- [x] redis持久化
  > 分为RDB和AOF以及混合三种。RDS是默认存储方式，保存某一时刻数据的快照，符合自定规则/执行save、bgsave（阻塞时间短）、flushall命令/第一次主从复制会触发快照，优点是占用空间小，性能好，缺点是会丢失最后一次快照以后的数据；AOF记录写过的所有命令，按顺序回放进行恢复，如果AOF体积过大，会自动重写成恢复当前数据集的的命令集合，缺点主要是性能差，不建议单独使用。
- [ ]redis内存溢出
  - 内存溢出会导致无法写入只能读，缓存命中率下降
  - 设置过期时间、使用数据淘汰策略
  - 排查内存是否够用、各缓冲区使用情况

## mysql

## 网络

- [ ]tcp udp区别
- [ ]三次握手、四次挥手
  
## 容器

- [ ]程序怎么部署的
