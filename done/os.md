# OS

- [OS](#os)
  - [操作系统](#操作系统)
    - [中断](#中断)
    - [引导程序](#引导程序)
    - [批处理系统](#批处理系统)
    - [并行/并发](#并行并发)
    - [分时系统](#分时系统)
    - [操作系统操作和功能](#操作系统操作和功能)
      - [双重模式](#双重模式)
      - [定时器](#定时器)
      - [进程管理](#进程管理)
      - [进行内存管理](#进行内存管理)
      - [文件管理](#文件管理)
  - [操作系统结构](#操作系统结构)
    - [操作系统服务](#操作系统服务)
    - [操作系统的结构](#操作系统的结构)
    - [虚拟机](#虚拟机)
  - [进程](#进程)
    - [进程通信](#进程通信)
  - [线程](#线程)
  - [CPU调度](#cpu调度)
    - [长程调度](#长程调度)
    - [短程调度](#短程调度)
    - [中程调度](#中程调度)
    - [调度队列](#调度队列)
    - [CPU调度方法](#cpu调度方法)
      - [先来先服务（FCFS）调度](#先来先服务fcfs调度)
      - [短作业优先调度](#短作业优先调度)
    - [优先级调度](#优先级调度)
    - [时间片轮转](#时间片轮转)
    - [多级队列调度](#多级队列调度)
    - [多处理器调度](#多处理器调度)
  - [进程同步](#进程同步)
    - [临界区](#临界区)
    - [信号量](#信号量)
      - [哲学家吃饭](#哲学家吃饭)
  - [死锁](#死锁)
    - [死锁避免](#死锁避免)
  - [内存管理](#内存管理)
    - [基本硬件](#基本硬件)
    - [内存管理的目的和功能](#内存管理的目的和功能)
    - [地址](#地址)
    - [指令和数据绑定到内存](#指令和数据绑定到内存)
    - [内存管理单元 MMU](#内存管理单元-mmu)
    - [动态加载和动态链接](#动态加载和动态链接)
    - [连续内存分配](#连续内存分配)
    - [分页内存管理](#分页内存管理)
    - [页表结构](#页表结构)
  - [分段内存管理](#分段内存管理)
    - [段页式内存管理](#段页式内存管理)
    - [内存扩充技术](#内存扩充技术)
  - [虚拟内存](#虚拟内存)
    - [写时复制](#写时复制)
    - [虚拟页式存储管理](#虚拟页式存储管理)
      - [请求分页](#请求分页)
      - [页面置换](#页面置换)

## 操作系统

### 中断

- 当出现需要时，CPU暂停当前程序的执行，转而执行处理新情况的程序和执行过程
- 中断号：外部设备进行I/O操作时产生的中断信号，发送给CPU
- 中断向量：中断服务程序的入口地址

### 引导程序

- 在打开电源或重启时被装载、初始化所有硬件、负责装入操作系统内核并开始运行
- 通常位于ROM或EPROM，称为固件

### 批处理系统

- 批处理：用户将一批作业提交操作系统后不再干预，由操作系统控制它们自动运行
- 批处理操作系统：采用批量处理作业技术的操作系统（单道/多道）
- 特点：不具有交互性、能提高CPU的利用率
- 多道程序设计：在内存中同时存在多道作业，在管理程序控制下相互穿插运行

### 并行/并发

- 并行：两个或多个作业在同一时刻运行
- 并发：两个或多个作业在同一时间间隔内依次运行
- 随着多核处理器出现，两个概念不严格区分
  
### 分时系统

- 分时系统是多道程序设计的延申
- 时间片：把一段CPU时间按照固定单位进行分割，每个分割得到的时间段称为一个时间片，每个任务依次轮流使用时间片
- 分时系统：一般采用时间片轮转方式使一台计算机为多个用户服务，单位时间内，每个用户获得一个时间片并运行

### 操作系统操作和功能

- 操作系统操作：双模式、I/O和内存保护、定时器
- 操作系统功能：进程管理、内存管理、文件管理、I/O系统管理

#### 双重模式

- 允许OS保护自身和其他系统部件，分为用户模式和内核模式。由硬件提供模式位、可能引起系统崩溃的指令（特权指令）只能运行在内核模式
- 用户程序要使用特权指令时，需要通过系统调用的方式
- 防止用户程序执行非法I/O，I/O指令都是特权指令

#### 定时器

- 在一段时间后发生中断，CPU控制权返回操作系统，防止用户程序死循环等问题

#### 进程管理

- 创建和删除用户和系统进程
- 暂停和恢复进程
- 提供进程同步机制
- 提供进程通信机制
- 提供死锁处理机制

#### 进行内存管理

- CPU只能直接访问寄存器、高速缓存、内存
- 处理前和处理后的数据都在内存
- 执行的指令都在内存
- 内存管理：提供内存的分配、回收、地址转换、共享和保护等功能
  
#### 文件管理

- 解决信息在计算机中存储问题
- 以文件为单位，以目录为组织方式构建文件系统

## 操作系统结构

### 操作系统服务

- 用户界面
- 程序执行
- I/O操作
- 文件系统操作
- 通信
- 错误检测
- 资源分配
- 统计
- 保护和安全

### 操作系统的结构

- 简单结构：MS-DOS、早期UNIX
- 层次结构：底层为硬件、最高层为用户层
- ios
- 微内核：尽可能把核内功能移出到用户空间
- 模块结构：大部分现代操作系统的结构。面向对象、核心部件分开、每个与其他模块的会话被称为接口、每个模块在需要时被加载到内核

### 虚拟机

- 通过软件模拟实现，具有完整硬件系统功能，运行在一个完全隔离环境中的完整计算机系统

## 进程

- 进程是计算机中的程序关于数据集合上的一次运行活动
- 进程控制块PCB：包括进程状态、程序计数器、CPU寄存器、I/O状态等信息

### 进程通信

- 两种基本模式
  - 共享内存：一块内存在多个进程间共享，通信由应用程序自己控制，可通过文件映射、管道、剪贴板等实现
  - 消息传递：
    - 直接通信
    - 间接通信：通过“信箱”
    - 阻塞（同步）/非阻塞（异步）

## 线程

- 可在CPU上运行的基本执行单位
- 自己不拥有系统资源，通过进程申请资源

| item   |  进程  |  线程 |
| :---: | :---: | :---: |
| 资源 | 进程是资源分配的基本单位 | 不用有资源，共享使用进程的资源 |
| 调度 | 同一进程中线程切换不会引起进程切换 | 基本调度单位 |
| 切换 | 进程：重量级上下文切换，代价大 | 轻量级切换，代价小 |

- 线程控制块PCB
- 优点：创建开销小、资源共享、创建和切换速度快
- 用户线程：由用户线程库进行管理的线程，内核看不到，在用户空间中创建和调度，也不需要内核干预
- 内核线程：由内核创建、调度、撤销
- 对应关系包括多对一、一对一、多对多等
  - 多对一：操作系统不支持内核线程，内核只能看到一个进程，多个线程不能并行运行在多个处理器，一个线程的系统调用会导致整个进程阻塞
  - 一对一：操作系统支持线程，用户线程映射到系统线程，再由操作系统管理，并发性好，内核开销大
  - 多对多：多个用户线程映射为相等或更小数目的内核线程

## CPU调度

### 长程调度

- 将已进入系统并处于后备状态的作业按某种算法选择一个或一批，为其建立进程，并进入主机，当该作业执行完毕时，还负责回收系统资源
- 在批处理系统中，需要长程调度以便将它们分批地装入内存，在分时系统和实时系统中，通常不需要长期调度。它的频率比较低，主要用来控制内存中进程的数量。

### 短程调度

- 又称为进程调度、低级调度或微观调度，使用最多。按照某种策略和算法将处理机分配给一个处于就绪状态的进程

### 中程调度

- 将进程在内存和外存间换进换出，节省内存空间

### 调度队列

- 就绪队列：在主内存中处于就绪状态并等待执行的所有进程集合
- 设备队列：等待某一I/O设备的进程队列
- 进程的执行过程就是进程在各种队列之间的迁移
- 调度程序：根据某种策略选择一个就绪进程、一个CPU同时只能运行一个进程
- 分派程序：把CPU控制权转交CPU调度程序、切换上下文、切换到用户态、跳转到用户程序的适当位置并重新运行
- 分派延迟：分派程序终止一个进程的运行并启动另一个进程运行所花的时间
- 非抢占调度：一旦把CPU分配给某进程后，系统不可以抢占已分配的CPU并分配个其他进程
  - 优点：易实现、调度开销小、适合批处理系统
  - 缺点：响应时间长、不适合交互式系统
- 抢占式调度：调度程序可根据某种原则暂停某个进程并把分配给他的CPU重新分配给另一进程
  - 可防止单一进程长时间独占CPU
  - 系统开销大
- 优化目标：
  - 最大的CPU利用率
  - 最大的吞吐量
  - 最短的周转时间
  - 最短的等待时间
  - 最短的响应时间

### CPU调度方法

#### 先来先服务（FCFS）调度

- 按进程请求CPU的先后顺序使用CPU
- 实现简单、非抢占、公平
- 长进程后面有多个短进程时，会让后面的短进程等待较长时间

#### 短作业优先调度

- 关联到每个进程下次运行的CPU区间长度、调度最短的进程
- 能给出最短的平均等待时间
- 难点在于如何知道下一个CPU区间的长度
- 常用于长程调度

### 优先级调度

- 基于进程的紧迫程度，赋予优先级。CPU分配给最高优先级的进程
- 默认小的优先数有高优先级
- 目前主流的操作系统调度方法
- 优先级可以静态不变，也可以动态调整（如随进程推进或等待时间增加而改变）
  - 例如，可以用响应比（等待时间/运行时间）
  - 优点：实现简单，考虑了进程的紧迫程度，灵活
  - 缺点：存在饥饿的问题，低优先级的进程可能永远得不到运行
  - 解决方法：老化——视进程等待时间的延长提高其优先数

### 时间片轮转

- 转为分时系统设计，类似于FCFS，但增加了抢占
- 时间片：小单位的CPU时间，通常为10-100毫秒
- 每个进程分配不超过一个时间片的CPU，时间片用完后，该进程被抢占并插入就绪队列末尾，循环执行
- 平均周转时间较长，但响应时间短
- 时间片越大，越趋近于FCFS，时间片越小，越增加上下文切换的时间损耗

### 多级队列调度

- 所有进程采用同一策略不合理，不同类型的进程使用不同策略，交互式的需要短的响应时间，批处理式的需要短的等待时间
- 系统中存在多个就绪队列，每个队列有自己的调度算法
- 要素：
  - 队列数
  - 每一队列的调度算法
  - 决定新进程进入哪个队列的方法
- 多级反馈队列：多级队列的延伸
  - 相比于普通的多级队列中，支持进程在不同队列间移动
  - 要素：队列数、每一队列的调度算法、决定进程升降级的方法

### 多处理器调度

- 适用多核处理器的CPU调度
- 对称多处理器：每个处理器决定自己的调度方案（主流）
- 非对称多处理器：进一个处理器能处理系统数据结构，减轻对数据的共享需求
- 负载平衡：将任务平均分配给各处理器
- 亲和性：进程在某个给定的CPU上尽量长时间的运行而不被迁移到其他处理器的倾向性
  - 软亲和性：进程通常不会在处理器之间频繁迁移
  - 硬亲和性：进程不会再处理器之间迁移
- 单队列多核调度法：系统有一个就绪队列，任一CPU空闲时，从队列中选择一个进程到CPU上运行（负载均衡，不具有亲和性）
- 多队列多和调度法：每个CPU一个就绪队列，每个队列有自己的调度算法且调度相对独立。（亲和性好，不需要加锁，负载不均衡）

## 进程同步

### 临界区

- 多个进程并发访问同一共享数据的情况
- 共享数据的最终结果取决于最后操作的进程
- 防止竞争条件的方法：并发进程同步或互斥
- 同步：协调执行次序
- 互斥：访问独占资源
- 临界资源：一次只允许一个进程使用，也叫做互斥资源、独占资源、共享变量
- 共享资源：一次允许多个进程使用的资源
- 临界区：涉及临界资源的代码段
- 临界区使用准则：
  - 有相同临界资源的临界区都需互斥
  - 有空让进
  - 有限等待

### 信号量

- 进入关键代码段前，进程必须获取一个信号量，否则不能运行；执行完后释放信号量。感觉像令牌，或者锁

#### 哲学家吃饭

- 5个哲学家围成一圈，5根筷子，每个人左右各有一根筷子，同时拿起两根筷子才能吃饭
- 问题实质：共享资源竞争
- 每个哲学家同时拿起左边的筷子，导致死锁
- 解决措施：
  1. 最多允许4个哲学家
  2. 仅当一个哲学家左右两边筷子都可用时，才允许拿筷子
  3. 给哲学家编号，奇数必须先拿左边筷子，偶数先拿右边筷子

## 死锁

- 一组等待进程，其中每一个进程都持有资源，并且等待着由这个族中其他进程所持有的资源
- 所有死锁进程无法推进
- 原因：
  - 竞争互斥资源
  - 进程推进不当
- 特征：
  - 互斥，一次只有一个进程可以使用一个资源
  - 占有并等待
  - 不可抢占
  - 循环等待
- 处理方法：
  1. 确保永远不会死锁（预防与避免）
  2. 允许进入死锁，然后检测并修复（检测与恢复）
  3. 忽略这个问题，假装没有发生（大部分的操作系统采用的方法，由开发人员自行处理死锁）

### 死锁避免

1. 一个简单有效的模型要求：每个进程声明他所需要的资源最大数
2. 死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立
3. 资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量所决定

- 安全状态：当进程申请一个有效的资源的时候，系统必须确定分配后是安全的
- 资源分配图法
- 银行家算法
  - 多个实例
  - 每个进程事先声明使用的最大量
  - 请求时可能等待
  - 当一个进程得到所有的资源，必须在有限时间释放

## 内存管理

### 基本硬件

- 程序必须装入内存才能执行
- CPU只能直接访问主存高速缓存和寄存器
- 寄存器通常可在1个CPU时装周期内完成访问，主存访问需要多个CPU时钟周期
- Cache位于主存和寄存器之间

### 内存管理的目的和功能

- 目的
  - 提高内存利用率
  - 提高指令执行速度
  - 保证指令安全运行
- 功能
  - 内存分配
  - 内存回收
  - 地址转换
  - 存储保护
  - 内存共享

### 地址

- 逻辑地址
  - CPU产生
  - 在进程内的相对地址
  - 也称虚拟地址、程序地址
- 物理地址
  - 内存地址
  - 所有内存统一编址
  - 也称绝对地址、实地址
- 基址寄存器：进程最小的合法物理内存地址
- 界限寄存器：进程地址的长度

### 指令和数据绑定到内存

- 地址绑定（重定位）：把程序中的相对地址转换为内存中的绝对地址
- 可以发生在编译、加载、执行三个不同阶段
- 动态地址绑定：在指令运行时，把程序中相对地址转换为内存中的绝对地址

### 内存管理单元 MMU

- 把虚拟地址映射到物理地址的硬件
- 是CPU管理内存的控制线路
- 在MMU策略中，基址寄存器中的值在送入内存时被加入到由一个用户进程所产生的每个地址中
- 用户程序对应到逻辑地址，物理地址对它不可见

### 动态加载和动态链接

- 动态加载
  - 例程在调用之前不加载，使用时加载
  - 不需要操作系统特别支持，通过程序设计实现
- 链接：将各种代码和数据片段收集并组合成为一个单一文件的过程
- 动态链接：组成程序的目标文件等到程序要运行时才链接
  - 和各种库文件的链接被推迟到执行时期
  - 需要动态装载技术支持
  - 需要操作系统支持

### 连续内存分配

- 为一个用户程序分配一个连续的内存空间
- 早期内存分配模式，用于内存较少系统
  - 单一连续分配
    - 整个内存的用户空间由该程序独占
    - 利用率低，用于单用户单任务OS
  - 固定分区分配
    - 可运行多道程序
    - 预先把主存空间分割成若干个连续区域
    - 分区大小可以不同，但固定不变，每个分区装一个程序
    - 如果有空闲分区，则分配给进程
  - 可变分区分配
    - 不同大小的分区分布在内存中，当进程到来，从一个足够容纳它分区中分配内存
    - 操作系统维护已分配和空闲分区表
    - 存储分配算法：首次适应、最佳适应、最差适应
    - 内存回收
    - 碎片
      - 外碎片：整个可用内存空间可以用来满足一个请求，但它不是连续的
      - 内碎片：分配的内存比申请的大一点，在分区内部但又不被使用
      - 通过紧缩减少外碎片，把一些小的空闲内存结合成一个大的块
      - 只有重定位是动态的时候才有可能紧缩，紧缩在执行期进行
- 主存通常分为两部分
  - 操作系统：通常在低端，因为中断矢量保存在低端
  - 用户进程：保存在内存高端

### 分页内存管理

- 现代操作系统常用方案
- 进程物理地址空间可能不连续
- 把物理内存分成大小固定的块，称为帧，把逻辑内存分成同样大小的块，称为页
- 系统保留所有空闲帧的记录
- 运行一个N页大小程序，要N个空帧来装入
- 建立页表，把逻辑地址转换为物理地址，分页地址被分为页号和页偏移
- 页表实现
  - 页表保存在主存中
  - 页表基址寄存器指向页表，页表限长寄存器表明页表长度
  - 这个机制中，每次数据/指令存取需要两次内存读取，一次存取页表，一次存取数据/指令
  - 采用小但专用且快速的硬件缓冲——转换表缓冲器（联想寄存器）
- 内存保护
  - 把页号和页表限长寄存器比较
  - 内存保护由与每个帧相连的保护位来实现
  - 有效表示相关页在进程的逻辑地址空间，并且是合法的页
  - 无效表示页不在进程的逻辑地址空间中
- 页共享
  - 共享代码：如果代码是可重入的，可以在进程间共享（文本编辑器，编译器，数据库系统）；一个程序多次运行：动态链接库
  - 私有代码和数据：每个进程保留一个代码和数据副本，存有私有数据和代码的页能出现在逻辑空间的任意位置

### 页表结构

- 32位逻辑地址，页大小4KB，一个页表最多可包含$2^{32}/2^{12}$个表项，每个页表项4个字节，要4MB放页表，1024个连续页面，不一定能实现
- 层次页表：比如两级页表，页号+页号+页偏移
- 哈希页表：通常地址空间>32位，虚拟页号被散列到一个页表中，这个页表的每一条目包括一个链表元素，这些元素哈希成同一位置。虚拟页号和链表中每个元素相比较，找到匹配项，取出相应的物理帧
- 反向页表：对于每个真正内存页或帧有一个条目。每个条目保存在真正内存位置的页的虚拟地址，也包括拥有这个页的进程的信息
  - 减少了需要储存每个页表的内存，增加了寻找页表所需时间
  - 使用哈希表将查找限制在一个或少数几个页表条目
  - 实现共享内存困难

## 分段内存管理

- 支持用户观点的内存管理机制，一个程序是一些段的集合，一个段是一个逻辑单位，如:main program, procedure, function, local variables, global variables, common block, stack, symbol table, arrays
- 段表：映射二维用户地址，每个表项包括基址和限长
- 由于段长度各不相同，内存分配是一个动态存储-分配问题
- 内存分配：首先/最佳适应法
- 外碎片问题
- 重定位：由段表执行
- 共享：共享的段，同样的段号
- 保护位：同段相联系，在段的级别进行代码共享

### 段页式内存管理

- 分段和分页的结合，逻辑地址=段号+页号+页内偏移

### 内存扩充技术

- 可变分区
- 覆盖技术
  - 程序大小超过物理内存总和
  - 之在内存中保留任何时间都需要的指令和数据
  - 程序的不同部分在内存中相互替换
  - 由程序员声明覆盖结构，不需要操作系统特别支持
  - 应用于早期的操作系统
- 交换技术
  - 多道程序环境下某些进程被阻塞但占用了大量内存
  - 进程被暂时交换到内存外的一个备份区，随后可以被换回内存继续执行
  - 滚入，滚出
  - 交换较为耗时，一般很少再采用
  - 进程运行时创建或修改的内容需要交换到磁盘
  - 不用或内存空间不够/有不够的风险时换出
  - 不应该换出处于等待I/O状态的进程
- 虚拟内存

## 虚拟内存

- 代码必须装入内存才能执行，但并不是所有代码必须全部装入内存
- 局部性原理：在一较短的时间内，程序的执行仅局限于某个部分，相应的，它所访问的存储空间也局限于某个区域
- 部分装入的好处：
  - 进程大小不受物理内存大小限制
  - 每个进程需要的内存更小
  - 更多进程可以并发运行
  - I/O更少
- 虚拟存储技术：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存执行
- 虚拟地址空间：分配给进程的虚拟内存
- 虚拟地址：在虚拟内存中指令或数据的位置
- 虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的内存，即虚存。区分开物理内存和用户逻辑内存
  - 只有部分运行的程序需要在内存中
  - 逻辑地址空间能够比物理地址空间大
  - 允许多个进程共享同一地址空间
  - 允许更有效地进程创建
- 虚拟内存的大小取决于操作系统的字长和内存外存容量和
- 通过虚拟页式或虚拟段式实现，虚拟页有请求分页和预调页两种方式

### 写时复制

允许父进程和子进程在初始化时共享页面，其中一个进程修改了共享页面，会产生副本

### 虚拟页式存储管理

- 进程开始运行前装入一个或零个页面，运行后根据需要动态装入其他页面，当内存空间已满而又需要装入新的页面时，根据某种算法置换内存中的某个页面，以便装入新的页面

#### 请求分页

- 只有在一个页需要的时候才把它换入内存
- 特点：
  - 只需要很少的I/O
  - 需要很少的内存
  - 快速响应
  - 多用户
  - 类似交换技术，粒度不同
- 有效位：每个页表有一个标志是否在内存中的位，初始化为0，即不在内存
- 首次访问一个页需要陷入OS，即缺页中断
  1. 访问指令或数据
  2. 查看另一个表确定是无效引用还是仅仅不在内存
  3. 找到页在后备存储上的位置
  4. 得到空的页框，把页换入页框
  5. 重新设置页表，把有效位设为v
  6. 重启指令
- $$有效访问时间 EAT=(1-p)\times内存访问时间+p\times页错误时间$$
- $$页错误时间=处理缺页中断+[页交换出去时间]+读入页时间+重启进程开销$$
- 页错误是计算机速度放慢的重要因子
- 采用交换区而不是文件系统，降低页面转换时间

#### 页面置换

- 基本页置换方法：
  1. 查找所需页在磁盘上的位置
  2. 查找空闲页框，如果没有，使用页置换算法选择一个“牺牲”页框，将其中内容写到磁盘上，更新页表和帧表
  3. 将所需页读入空闲页框，更新页表和帧表
  4. 重启用户进程
- 如果发生页置换，则缺页处理时间加倍，使用modify bit来防止页面转移过多，只有被修改的页面才写入磁盘
- 页面置换算法
  - 最优置换置换算法（不能实现，作为一种标准衡量其他算法）
  - 先进先出置换算法（性能差）
  - 最近最少使用置换算法（性能好，开销大）
  - 二次机会置换算法
  - 不经常使用算法
