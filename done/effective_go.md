# effective_go

- 包外名称是否可见取决于第一个字符是否大写
- 包的名字应该小写，只有一个单词，不需要下划线和大写字母
- 包名是源目录的base name
- 一个有用的文档注释好于一个超长的包名
- 不提供getter和setter的自动支持。字段是owner的话，方法名可以用Owner和SetOwner
- 单方法接口名称用方法名称加上-er或类似的修饰命名，除非是含义相同的方法，不要碰瓷Read、Write、String等常用的方法名
- 一般使用驼峰法而非下划线
- go使用分号来终止语句，但可以自动插入。所以不能把控件结构的左大括号放在下一行
- 两个:=，第一个:=声明，第二个:=重新赋值，条件是：
  1. 处于相同的作用域
  2. 初始化中对应的值可以赋值给他
  3. 至少还有一个由声明创建的其他变量
- 函数参数和返回值的作用域和函数体相同
- 统一了for和while
  - for init; condition; post {}
  - for condition {}
  - for {}
  - 在数组、切片、字符串、map上循环可以用range
  - 没有逗号运算符，**++是语句而不是表达式**，如果想在for之前声明多个变量需要并行赋值
- switch中多个case可以用逗号分隔
- 在循环上放一个标签然后可以用break标签跳出循环
- switch可以发现接口变量的动态类型
- 允许返回多个返回值，返回值可命名
- 这个例子将会输出4 3 2 1 0

    ``` golang
    for i := 0; i < 5; i++ {
        defer fmt.Printf("%d ", i)
    }
    ```

- new是第一个内建函数用于分配内存，但不初始化，只将内存归0
- 如果复合文本不包含任何字段，为类型创建一个零值。new(File)等价于&File{}
- make 只创建切片，map，channel，并返回一个初始化的（非零）T，而不是*T。这三种类型代表了使用前必须初始化的数据结构的引用。
- Go和C的不同：
  - 数组是值，把一个数组指定给另一个会复制所有的值
  - 传递一个数组给函数，会接收数组的副本，而不是指向它的指针
  - 数组的大小是类型的一部分，[10]int和[20]int不同
- golang更青睐的是切片
  - 切片保存对底层数组的引用，如果将一个切片赋值给另一个，两个切片都引用同一个数组，对切片元素做的更改对调用者可见
  - nil切片的len和cap都是0
  - 二维切片即切片中的切片，有两种构造方式：一种是独立的分配每个片，另一种是分配单个数组然后分割成多个片，取决于切片是否会增长或者收缩
- map
  - map的键值可以是定义了相等运算符的任何类型
  - 使用冒号分隔的键值对来初始化
  - **使用不存在的键会返回值类型的0值**
  - 为了区分是键不存在还是值为0，可以用“逗号 ok”的习惯用法，通过ok的值进行辨别
  - delete用来删除键，即使键已经消失了，删除也是安全的
- Print只有两边的操作数都不是字符串时，版本才会添加空格
- 如果要控制自定义类型的默认格式，只需要一个带有签名String() string 的方法
  - 如果要打印values of type T 以及 pointers to T,String的接收器必须是值类型
  - 不要在方法中用Sprintf构造String，可能会无限循环。如果要这样做，要把Sprintf的参数转换为基本的字符串类型string
- maybe...可以解切片？（这里需要一个精确的说法）
- 常量在编译时创建，所以定义常量的表达式必须是常量表达式，可由编译器求值
- 枚举常用iota
- 值方法可以在指针和值上调用，指针方法只能在指针上调用（指针方法可以修改接收方）但如果可以寻址，编译器会自动插入地址运算符
- 只有一两个方法的接口是常见的，并且通常被赋予从一个方法派生的名字，一个类型可以实现多个接口
- 接口转换和类型断言

    ```golang
        type Stringer interface {
            String() string
        }

        var value interface{} // Value provided by caller.
        switch str := value.(type) {
        case string:
            return str
        case Stringer:
            return str.String()
        }
    ```

  - 类型断言失败会导致崩溃，可以用“comma, ok”语法安全的测试
- 如果有导入之后要使用的包，可以用空白标识符紧跟在导入后面做一个全局声明，后续进行清理
- 如果要只导入包的副作用的话，可以用空白标识符重命名软件包
- 如果没有实现静态的接口转换，可以通过构造空白标识符例如
  
  `var _ json.Marshaler = (*RawMessage)(nil)`

- 接口嵌入
  - 嵌入和子类化有个一个重要区别，嵌入一个类型时，类型的方法变成外部类型的方法，但是调用时，方法的接收者是内部类型
- 不要通过共享内存进行通信，而是通过通信来共享内存
- goroutines：在同一个地址空间和其他goroutines一起执行的函数。在函数或方法前加上go去调用，调用完成后goroutine退出，静默
- 在go中，函数常量是闭包，确保函数引用的变量只要是活动的就存在
- 通过make创建channel，接收器阻塞直到有数据要接受，如果无缓冲，则发送方阻塞直到接收方收到数据；如果有缓冲，直接复制到缓冲区
- 使用相同名称的变量可以在本地隐藏外层的变量
- 通道是可以分配和传递的第一类值，可以实现通道的通道
- 并行化的任务，按照CPU核的数量进行拆分（理想情况下），runtime.NumCPU()返回CPU内核的数量
- 错误字符串应尽可能标识来源，可以用类型开关或类型断言查找特定的错误和提取详细信息
- panic创建一个运行时错误，打印信息（参数里的字符串）并停止程序，尽量避免panic
- 在goroutines中可以使用defer+recover，防止goroutines中的panic影响到主程序和其他的goroutines
