# ETCD

高可用分布式键值数据库，机器间通过raft算法通信，具有强一致性

- [ETCD](#etcd)
  - [使用场景](#使用场景)
  - [概念词汇表](#概念词汇表)
  - [分布式系统与一致性协议](#分布式系统与一致性协议)
    - [一致性](#一致性)
      - [以数据为中心的一致性模型](#以数据为中心的一致性模型)
      - [以用户为中心的一致性模型](#以用户为中心的一致性模型)
      - [复制状态机](#复制状态机)
    - [Raft协议](#raft协议)

## 使用场景

- 键值对存储
- 服务注册与发现
  - 强一致性、高可用的服务存储目录（通过raft算法支持）
  - 注册服务和服务健康状况的机制。 用户可以在 etcd 中注册服务，并且对注册的服务配置 key TTL，定时保持服务的心跳以达到监控健康状态的效果
  - 查找和连接服务的机制。通过在 etcd 指定的主题下注册的服务也能在对应的主题下查找到。可以在每个服务机器上都部署一个 Proxy 模式的 etcd，这样就可以确保访问 etcd 集群的服务都能够互相连接
- 消息发布与订阅
  - etcd集中管理配置信息。应用在启动的时候主动从etcd获取一次配置信息，同时在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者
  - 分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在etcd中，供各个客户端订阅使用。使用etcd的key TTL功能可以确保机器状态是实时更新的。
  - 分布式日志收集系统。收集器通常是按照应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（主题）命名的目录P，并将这个应用（主题相关）的所有机器ip，以子目录的形式存储到目录P上，然后设置一个 etcd 递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。
  - 动态自动获取信息与人工干预修改信息请求内容。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入etcd之后，就不用自己实现一套方案了，只要将这些信息存放到指定的etcd目录中即可，etcd的这些目录就可以通过HTTP的接口在外部访问。
- 分布式通知与协调
  - 类似消息发布和订阅，用到了etcd中的Watcher机制，不同系统都在etcd上对同一个目录进行注册，同时设置Watcher观测该目录的变化（如果对子目录的变化也有需要，可以设置递归模式），当某个系统更新了etcd的目录，那么设置了Watcher的系统就会收到通知，并作出相应处理。
  - 低耦合的心跳检测
  - 系统调度。管理人员修改etcd上某些目录节点的状态，而etcd就把这些变化通知给注册了Watcher的客户端，完成调度
  - 工作汇报。子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度进行汇报（将进度写入到这个临时目录）
- 分布式锁
  - 分布式环境下不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题
  - 锁服务有两种使用方式，一是保持独占（所有获取锁的用户最终只有一个可以得到），二是控制时序（所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序）

## 概念词汇表

- Raft：etcd所采用的保证分布式系统强一致性的算法
- Node：一个Raft状态机实例
- Member： 一个etcd实例。它管理着一个Node，并且可以为客户端请求提供服务
- Cluster：由多个Member构成可以协同工作的etcd集群
- Peer：对同一个etcd集群中另外一个Member的称呼
- Client： 向etcd集群发送HTTP请求的客户端
- WAL：预写式日志，etcd用于持久化存储的日志格式
- snapshot：etcd防止WAL文件过多而设置的快照，存储etcd数据状态
- Proxy：etcd的一种模式，为etcd集群提供反向代理服务
- Leader：Raft算法中通过竞选而产生的处理所有数据提交的节点
- Follower：竞选失败的节点作为Raft中的从属节点，为算法提供强一致性保证
- Candidate：当Follower超过一定时间接收不到Leader的心跳时转变为Candidate开始竞选
- Term：某个节点成为Leader到下一次竞选时间，称为一个Term
- Index：数据项编号。Raft中通过Term和Index来定位数据

## 分布式系统与一致性协议

分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统

分布式系统的设计目标：可用性，可扩展性，容错性，性能。

### 一致性

通俗地讲，一致性就是不同的副本服务器认可同一份数据。很多场景都要求一致性，但并不是所有的系统都要求是强一致的。甚至银行转账之类的场景，也存在不一致的时间窗口。

从客户端来看，一致性主要是指多并发访问时如何获取更新过的数据的问题。从服务端来看，则是更新如何复制分布到整个系统。

#### 以数据为中心的一致性模型

严格一致性：任一次读都能读到某个数据最近一次写的数据、系统中所有进程看到的操作顺序都和全局时钟下的顺序一致。强一致的子操作组成的父操作也是强一致的。

顺序一致性：也成为可序列化，放弃全局时钟的约束，改为分布式逻辑时钟实现。所有的进程都以相同的顺序看到所有的修改，实际上就是要求所有进程达成一致。弱于严格一致性。

因果一致性：

> 本地顺序：本进程中事件执行的顺序为本地因果顺序。
>
> 异地顺序：如果读操作返回写操作的值，写操作应在读操作之前。
>
> 闭包传递：与时钟向量里定义的一样，如果a->b且b->c，则有a->c
>
> 否则，操作之间为并发关系。对于有潜在因果关系的写操作，所有进程执行顺序相同。并发写操作在不同主机上看到的顺序可以不同。一般弱于顺序一致性。

可串行化一致性：可序列化允许对操作重新进行任意排序，只要顺序看起来是原子的即可，一致性可能很强又可能很弱。

#### 以用户为中心的一致性模型

最终一致性：如果更新的时间间隔比较长，所有副本能够最终达到一致性。

#### 复制状态机

一个分布式的复制状态机系统由多个复制单元组成，每个复制单元均是一个状态机，它的状态保存在一组状态变量中。状态机的状态能够并且只能通过外部命令来改变。

一组状态变量”通常是基于操作日志来实现的，这时一致性算法的主要工作就变成了如何保证操作日志的一致性。但是，指令在状态机上的执行顺序并不一定等同于指令的发出顺序或接收顺序。

拜占庭错误：最强的错误，某些恶意节点扰乱系统正常运行，包括选择性不传递、选择性伪造消息。进程失败错误：最弱的错误，出错时节点停止运行，其他所有的节点都知道该节点发生了错误。要容忍N个拜占庭错误，至少要有2N+1个复制节点，如果把错误类型缩小到进程失败，则至少需要N+1个。

FLP定理：在允许节点失效的场景下，基于异步通信方式的分布式协议无法确保在有限的时间内达成一致性，即使只有一个节点失效。

### Raft协议

Raft协议把问题分解成领袖选举、日志复制、安全性、成员关系变化这几个子问题。在一个领袖节点发生故障后必须重新给出一个新的领袖节点；领袖节点从客户端接收操作请求，然后将操作日志复制到集群中的其他服务器上，并强制要求其他服务器的日志和自己保持一致；安全性指的是如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目；配置发生变化时集群能继续工作。

Raft集群中的节点通过远端过程调用（RPC）来进行通信，Raft算法的基本操作只需2种RPC即可完成。RequestVote RPC是在选举过程中通过旧的Leader触发的，AppendEntries RPC是领导人触发的，目的是向其他节点复制日志条目和发送心跳。

基于简化操作和效率等因素考虑，Raft算法采用的是非对称节点关系模型。只有主节点有决策权，任何时刻只有一个主节点，客户端只和主节点交互。一共有3类角色，Leader、Candidate、Follower。

一开始所有节点都是群众，第一轮选举都可以成为候选人，一旦某位候选人得到半数选票，就成为领袖，开始一个新的任期，其他候选人回到群众身份并接受领导。任期实际上承担了逻辑时钟的作用，同时检测过期信息。每个节点在本地维护一个任期值，节点通信时交换当前任期号，如果一个节点的任期号比其他的小，则将本地的任期号更换为较大的任期号；如果一个候选人或领袖意识到他的任期号比别的小，则切换回群众；如果一个节点收到请求携带过期的任期号，则拒绝响应。

每个Raft节点都有一个选举定时器，所有的Raft节点最开始以Follower角色运行时，都会启动这个选举定时器。不过，每个节点的选举定时器时长均不相等。Leader在任期内必须定期向其他节点广播心跳，Follower每次收到心跳就将自己的选举定时器清零重置，如果选举定时器超时，Follower就假定Leader不存在并发起选举。如果一个Foller决定参加选举，首先将本地维护的任期号+1，将自己的状态切换到Candidate，并为自己投票，向其他节点发送RequestVote RPC，要求投票给自己。如果得到了大多数选票则成为Leader，一个节点只能为一个Candidate投票，先到先得的投票给最早拉票的候选者；如果等待投票时收到了声称自己是Leader的心跳包，会检查任期号，如果比自己的任期号大则认为合法，否则拒绝并返回新的任期号告诉其已经过期；如果没有Candidate获得半数以上选票，为每个候选人设置超时时间，超时后候选人自增任期号并发起新的拉票，通过随机超时的时间以使得大多数时候只有一个节点率先超时。

一旦某个领导人赢得选举，就开始接收客户端请求，每个请求解析成一条需要复制状态机执行的指令，Leader将指令作为一条新的日志条目加入它的日志文件，并行地向其他Raft节点发起AppenEntries RPC，要求其他节点复制这个日志，当日志被“安全”地复制之后，Leader将日志应用到状态机中并向客户端返回执行结果。如果Follower没有及时响应，Leader会无限重试（甚至在它响应了客户端之后）直到所有Follower最终存储了一样的日志条目。每条日志包括索引、任期号、指令。如果某个条目被复制到半数以上的节点，该条目就是可提交的。Raft算法保证可被提交的日志条目是持久化的，并且最终是会被所有状态机执行的。

领导人跟踪所知道的被提交日志条目的最大索引值，并且这个值包含在向其他节点发送到AppendEntries RPC中，一旦Follower得知某个日志条目被提交，它会将其应用至本地的状态机。日志机制：**如果不同的日志中的两个条目有相同的索引号和任期号，它们存储的命令相同，且他们之前的条目完全一样。**这由两个条件保证，领导人在一个任期里在给定的一个日志索引位置上最多创建一条日志条目，同时该条目在日志文件中的槽位永远也不会改变；领导人发送消息试图追加条目时，也把新日志条目前一个槽位的日志条目的任期号和索引号包含在消息体，如果Follower没在自己的日志中找到相同任期号和索引的日志，就拒绝该RPC。

一个新的Leader被选举出来，日志与Follower可能不一样，Follower可能丢失或者多出一些未提交的条目。Leader会强制Follower复制它的日志，找到第一个不一致的位置然后删除之后的所有日志，并把自己的日志发送给Follower。

一次正常的复制流程：客户端向Leader发送写请求；Leader将请求解析成操作指令追加到日志文件；为每个follower广播AppendEntries RPC；Follower通过一致性检查，选择从哪个位置开始追加日志条目；一旦日志项提交成功，Leader就应用该条目对应的指令并向客户端返回操作结果；Leader通过AppendEntries RPC将已经在大多数节点上成功提交的日志告知Follower；Follower收到后应用至本地状态机。

**没有包含所有已提交日志条目的节点成为不了领导人；日志条目只能从Leader流向Follower。领导人永远不会覆盖已经存在的日志条目。**如果一个节点的日志比候选人的日志更新，就会拒绝候选人的投票请求，比较的依据是日志文件中最后一个条目的索引和任期号。Raft算法对日志提交条件增加了一个额外的限制：要求Leader在当前任期至少有一条日志被提交，即被超过半数的节点写盘。

选举并且保持一个稳定的领导人存在的条件：节点发送RPC并收到响应的平均时间<<选举超时时间<<单个节点故障平均间隔时间。

领导人故障的情况：（1）数据到达之前，不会影响一致性；（2）数据到达Leader但未复制到Follower，此时处于未提交状态，客户端不会收到ack而是认为超时发起重试；（3）到达Leader并成功复制到部分节点，但还未向Leader响应接收时，数据在Follower处于未提交状态，只有拥有新数据的节点能被选为Leader；（4）数据到达Leader节点，成功复制到Follower的所有节点上，但还未向Leader响应接收，也能保持一致，但由于客户端不知道有没有提交成功，可重试提交，因此要求rpc是幂等的；（5）数据到达Leader，成功复制到所有或者大多数节点，Leader已提交但Follower未提交，与阶段3一致；（6）所有节点都已提交，但还未响应Client，此时内部已经是一致的；（7）网络分区导致双Leader，向旧的Leader提交不可能成功，向新的Leader提交可以成功，网络恢复后旧的Leader自动降级Follow并从新的Leader同步。